# <트리>
# 노드: 트리의 원소
# 간선: 부모 노드와 자식 노드를 연결하는 선
# 루트 노드: 트리의 시작 노드

# 트리 T
# A(레벨0: 높이0) ┌ B(레벨1: 높이1) ┌ E(레벨2: 높이2)
#                |               L F(레벨2: 높이2) - K(레벨3: 높이3): 트리의 높이
#                | C(레벨1: 높이1) ┌ G(레벨2: 높이2)
#                L D(레벨1: 높이1) L H(레벨2: 높이2)
#                                 ┌ I(레벨2: 높이2)
#                                 L J(레벨2: 높이2)

# 형제 노드: 같은 부모 노드의 자식 노드들 (B,C,D 는 형제 노드)
# 조상 노드: 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들 (K 의 조상 노드: F, B, A)
# 서브 트리: 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
# 자손 노드: 서브 트리에 있는 하위 레벨의 노드들 (B 의 자손 노드: E, F, K)

# <차수>
# 노드의 차수: 노드에 연결된 자식 노드의 수(B 의 차수: 2, C 의 차수: 1)
# 트리의 차수: 트리에 있는 노드의 차수 중 가장 큰 값(트리 T 의 차수: 3)
# 단말 노드(리프 노드): 차수가 0인 노드. 자식 노드가 없음

# <높이>
# 노드의 높이: 루트에서 노드에 이르는 간선의 수. 노드의 레벨(B 의 높이: 1, F 의 높이: 2)
# 트리의 높이: 트리에 있는 노드의 높이 중에서 가장 큰 값. 최대 레벨(트리 T 의 높이: 3)

# ==============================================================================

# <이진트리>
# 모든 노드들이 2개 이하의 서브트리를 갖는 특별한 형태의 트리 -> 0개도 가능
# 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있음: 왼쪽 자식 노드(L), 오른쪽 자식 노드(R)
# 레벨 I 에서의 노드의 최대 개수는 2^I 개
# 높이 h 인 이진트리가 가질 수 있는 노드의 최소 개수는 (h + 1 -> 0레벨인 노드도 추가해야 함)개, 최대 개수는 (2^(h+1) -1)개

# <포화이진트리>
# 모든 레벨에 노드가 포화상태로 차 있는 이진트리
# 높이가 h 일 때, 최대 노드 개수인 (2^(h+1) -1)의 노드를 가진 이진 트리(높이가 3일 때 2^(3+1) -1 = 15개)
# 루트를 1번으로 하여 (2^(h+1) -1)까지 정해진 위치에 대한 노드 번호를 가짐

# <완전이진트리>
# 트리의 높이가 h 일 때, h - 1층까지는 모든 노드들이 꽉 채워져있고
# h 번째 층의 값들은 '왼쪽' 부터 '차례로' 채워져 있는 트리
# 2^h (h-1 레벨까지 꽉 차있고(2^h-1), h 레벨에 1개 이상(+1)) <= n <= 2^(h+1) -1

# <편향이진트리>
# 높이 h 에 대한 최소 개수의 노드르 가지면서 한쪽 방향의 자식 노드만을 가진 이진트리
# 왼쪽 편향 이진 트리 / 오른쪽 편향 이진 트리

# ==============================================================================

# <이진트리(자식이 최대 2개인 트리)- 순회>
# <순회>란?
# 트리의 각 노드를 중복되지 않게 전부 방문하는 것
# 트리는 비선형 구조이기 때문에 선형구조에서와 같이 선후 연결관계를 알 수 없음
# ***3가지의 기본적인 순회 방법*** 1개만 알아도 나머지는 자동으로 따라오는 느낌..?

#             루트(V): 부모
#           |              |
#     왼쪽 서브트리(L)  오른쪽 서브트리(R)

# 전위순회 빼고 쩨에에에에일 왼쪽부터 리턴하고 왼쪽이 없으면 오른쪽 확인! 항상 왼쪽 우선

# 1. 전위순회(VLR: V-> L-> R): '부모노드' 방문 후, 자식 노드를 좌,우 순서로 방문
def preorder_travers(T):  # 전위순회(부모노드가 제일 앞에)
    if T:  # T is not None
        visit(T)  # print(T.item) # 현재 노드 n 을 방문하여 처리한다(V)
        preorder_travers(T.left)  # 현재 노드 n 의 왼쪽 서브트리로 이동(L)
        preorder_travers(T.right)  # 현재 노드 n 의 오른쪽 서브트리로 이동(R)

# 2. 증위순회(LVR: L-> V-> R): 왼쪽 자식노드, '부모노드', 오른쪽 자식노드 순으로 방문
def inorder_traverse(T):  # 중위순회(부모노드가 중간에)
    if T:  # T is not None
        inorder_traverse(T.left)  # 현재 노드 n 의 왼쪽 서브트리로 이동(L)
        visit(T) # print(T.item) # 현재 노드 n 을 방문하여 처리한다(V)
        inorder_traverse(T.right)  # 현재 노드 n 의 오른쪽 서브트리로 이동(R)

# 3. 후위순회(LRV: L-> R-> V): 자식노드를 좌우 순서로 방문한 후, '부모노드' 로 방문
def postorder_traverse(T):
    if T:
        postorder_traverse(T.left)  # 현재 노드 n 의 왼쪽 서브트리로 이동(L)
        postorder_traverse(T.right)  # 현재 노드 n 의 오른쪽 서브트리로 이동(R)
        visit(T) # print(T.item) # 현재 노드 n 을 방문하여 처리한다(V)

# <'배열' 을 이용한 이진트리의 표현>
# 포화이진트리 or 완전이진트리: 보통 1차원 배열에서 0번은 비워두고 1번부터 채움! (무조건 아님 조건 잘 보고!)
# 왼쪽: 부모번호 * 2 / 오른쪽: 부모번호 * 2+1
# 부모 노드를 알고 싶다면? -> n(자식노드 번호) // 2
# 자식번호가 왼쪽이 더 작다 이런 조건이 없으면 자식번호 주어진 순서대로 넣으면 됌.
# [부모번호를 인덱스] 로 자식 번호를 저장!
# 1) [자식번호를 인덱스] 로 부모번호를 저장! 1) 2)
for i: 1-> None
    read p, c  # p: 부모 / c: 자식
    par[c] = p

# 2) 루트 찾기, 조상 찾기
c = 5  # 5번 노드의 조상 찾기
while (a[c]) != 0):  # 루트인지 확인
    c = a[c]  # a: 부모 / c: 자식
    anc.append(c)  # 조상 목록
root = c

# ==============================================================================

# <연습문제 3>
# 13 정점의 개수
# 1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13 노선

n = int(input())  # 13

# 왼쪽 자식 배열
left = [0 for _ in range(n+1)]  # 0번 인덱스는 사용x so +1
# 오른쪽 자식 배열
right = [0 for _ in range(n+1)]

# 부모 - 자식
arr = list(map(int, input().split()))  #[부모1, 자식1, 부모2, 자식2, ... ]

# 부모 자식을 순회하면서 왼쪽, 오른쪽 자식을 넣어주는 과정
for i in range(0, len(arr), 2):  # 0부터 끝까지 2스텝으로
    # 부모 i, 자식 i+1
    p = arr[i]
    c = arr[i + 1]
    # 왼쪽 자식이 있는지 여부 -> 없다면 왼쪽에 자식 할당
    if left[p] == 0:
        left[p] = c
    # -> 있다면 오른쪽에 할당
    else:
        right[p] = c

# 카운트 변수 (전역)
count = 0
# 전위순회(VLR) (재귀로), 서브트리에 포함되는 노드의 갯수
def VLR(t):  # 현재 순회하려는 노드
    global count
    if t != 0:  # 값이 있다면
        count += 1  # V
        VLR(left[t])  # L 왼쪽
        VLR(right[t])  # R 오른쪽

count = 0
# 중위순회 (LVR)
def LVR(t):  # 현재 순회하려는 노드
    global count
    if t != 0:  # 값이 있다면
        VLR(left[t])  # L 왼쪽
        count += 1  # V
        VLR(right[t])  # R 오른쪽

count = 0
# 후위순회 (LRV)
def LVR(t):  # 현재 순회하려는 노드
    global count
    if t != 0:  # 값이 있다면
        VLR(left[t])  # L 왼쪽
        VLR(right[t])  # R 오른쪽
        count += 1  # V

VLR(5)
print(count)
